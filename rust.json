{
  // Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "inputMacro": {
    "prefix": "inp",
    "body": [
      "macro_rules! input {",
      "    (source = \\$s:expr, \\$(\\$r:tt)*) => {",
      "        let mut iter = \\$s.split_whitespace();",
      "        let mut next = || { iter.next().unwrap() };",
      "        input_inner!{next, \\$(\\$r)*}",
      "    };",
      "    (\\$(\\$r:tt)*) => {",
      "        let stdin = std::io::stdin();",
      "        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));",
      "        let mut next = move || -> String{",
      "            bytes",
      "                .by_ref()",
      "                .map(|r|r.unwrap() as char)",
      "                .skip_while(|c|c.is_whitespace())",
      "                .take_while(|c|!c.is_whitespace())",
      "                .collect()",
      "        };",
      "        input_inner!{next, \\$(\\$r)*}",
      "    };",
      "}"
    ]
  },
  "inputInnerMacro": {
    "prefix": "inpin",
    "body": [
      "macro_rules! input_inner {",
      "    (\\$next:expr) => {};",
      "    (\\$next:expr, ) => {};",
      "    (\\$next:expr, \\$var:ident : \\$t:tt \\$(\\$r:tt)*) => {",
      "        let \\$var = read_value!(\\$next, \\$t);",
      "        input_inner!{\\$next \\$(\\$r)*}",
      "    };",
      "}",
    ]
  },
  "readValueMacro": {
    "prefix": "readv",
    "body": [
      "macro_rules! read_value {",
      "    (\\$next:expr, ( \\$(\\$t:tt),* )) => {",
      "        ( \\$(read_value!(\\$next, \\$t)),* )",
      "    };",
      "    (\\$next:expr, [ \\$t:tt ; \\$len:expr ]) => {",
      "        (0..\\$len).map(|_| read_value!(\\$next, \\$t)).collect::<Vec<_>>()",
      "    };",
      "    (\\$next:expr, chars) => {",
      "        read_value!(\\$next, String).chars().collect::<Vec<char>>()",
      "    };",
      "    (\\$next:expr, usize1) => {",
      "        read_value!(\\$next, usize) - 1",
      "     };",
      "     (\\$next:expr, \\$t:ty) => {",
      "         \\$next().parse::<\\$t>().expect(\"Parse error\")",
      "    };",
      "}"
    ]
  },
  "readFunction": {
    "prefix": "readm",
    "body": [
      "use std::io::*;",
      "use std::str::FromStr;",
      "fn read<T: FromStr>() -> T {",
      "    let stdin = stdin();",
      "    let stdin = stdin.lock();",
      "    let token: String = stdin",
      "        .bytes()",
      "        .map(|c| c.expect(\"failed to read char\") as char) ",
      "        .skip_while(|c| c.is_whitespace())",
      "        .take_while(|c| !c.is_whitespace())",
      "        .collect();",
      "    token.parse().ok().expect(\"failed to parse token\")",
      "}",
    ]
  },
  "UnionFind": {
    "prefix": "union",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct UnionFind {",
      "    par: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    group: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl UnionFind {",
      "    fn new(n: usize) -> Self {",
      "        UnionFind {",
      "            par: (0..n).collect(),",
      "            rank: vec![0; n],",
      "            group: vec![1; n],",
      "        }",
      "    }",
      "    fn find(&mut self, x: usize) -> usize {",
      "        if self.par[x] == x {",
      "            x",
      "        } else {",
      "            let px = self.par[x];",
      "            let root = self.find(px);",
      "            self.par[x] = root;",
      "            root",
      "        }",
      "    }",
      "    fn unite(&mut self, x: usize, y: usize) {",
      "        let x = self.find(x);",
      "        let y = self.find(y);",
      "        if x == y {",
      "            return",
      "        }",
      "        if self.rank[x] < self.rank[y] {",
      "            self.group[y] += self.group[x];",
      "            self.par[x] = y;",
      "        } else {",
      "            self.group[x] += self.group[y];",
      "            self.par[y] = x;",
      "        }",
      "        if self.rank[x] == self.rank[y] {",
      "            self.rank[y] += 1;",
      "        }",
      "    }",
      "    fn group_size(&mut self, x: usize) -> usize {",
      "        let p = self.find(x);",
      "        self.group[p]",
      "    }",
      "}",
    ]
  },
  "directions": {
    "prefix": "dire",
    "body": [
      "let dire: Vec<(isize, isize)> = vec![(1, 0), (0, 1), (-1, 0), (0, -1)];",
      "let dire8: Vec<(isize, isize)> = vec![(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)];"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
    ]
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "fn lcm(a: u64, b:u64) -> u64 {",
      "    a * b / gcd(a, b)",
      "}",
    ]
  },
  "mod_pow": {
    "prefix": "modp",
    "body": [
      "fn mod_pow(x: u64, n: u64, m: u64) -> u64 {",
      "    let mut res = 1;",
      "    let mut x = x;",
      "    let mut n = n;",
      "    while n > 0 {",
      "        if n & 1 == 1 {",
      "            res = (res * x) % m;",
      "        }",
      "        x = (x * x) % m;",
      "        n = n >> 1;",
      "    }",
      "    res",
      "}",
    ]
  },
  "mod_inverse": {
    "prefix": "modi",
    "body": [
      "fn mod_inv(a: u64, m: u64) -> u64 {",
      "    let (_, x, _) = extgcd(a as i64, m as i64);",
      "    (m as i64 + x) as u64 % m",
      "}",
    ]
  },
  "extended gcd": {
    "prefix": "extg",
    "body": [
      "fn extgcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    if b == 0 {",
      "        (a, 1, 0)",
      "    } else {",
      "        let (gcd, x, y) = extgcd(b, a % b);",
      "        (gcd, y, x - (a / b) * y)",
      "    }",
      "}",
    ]
  },
  "FactInverse": {
    "prefix": "facti",
    "body": [
      "#[derive(Debug)]",
      "struct FactInv {",
      "    fact: Vec<u64>,",
      "    inv: Vec<u64>,",
      "    factinv: Vec<u64>,",
      "    m: u64,",
      "}",
      "#[allow(dead_code)]",
      "impl FactInv {",
      "    fn new(n: u64, m: u64) -> Self {",
      "        let mut fact = vec![0; n as usize + 1];",
      "        fact[0] = 1;",
      "        for i in 1..n+1 {",
      "            fact[i as usize] = i * &fact[i as usize - 1] % m;",
      "        }",
      "        let mut inv = vec![0; n as usize + 1];",
      "        inv[0] = 0;",
      "        inv[1] = 1;",
      "        for i in 2..n+1 {",
      "            inv[i as usize] = inv[(m % i) as usize] * (m - m / i) % m;",
      "        }",
      "        let mut factinv = vec![0; n as usize + 1];",
      "        factinv[0] = 1;",
      "        for i in 1..n+1 {",
      "            factinv[i as usize] = factinv[i as usize - 1] * inv[i as usize] % m;",
      "        }",
      "        FactInv {",
      "            fact: fact,",
      "            inv: inv,",
      "            factinv: factinv,",
      "            m: m,",
      "        }",
      "    }",
      "    fn comb(&self, n: u64, r: u64) -> u64 {",
      "        if n < r {",
      "            0",
      "        } else {",
      "            (self.fact[n as usize] * self.factinv[r as usize] % self.m) * self.factinv[(n-r) as usize] % self.m",
      "        }",
      "    }",
      "}",
    ]
  },
  "alphabets": {
    "prefix": "alpha",
    "body": [
      "let alphabets = vec!['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];"
    ]
  },
  "digit_sum": {
    "prefix": "digits",
    "body": [
      "fn digit_sum(n: i64, b: i64) -> i64 {",
      "    if n < b {",
      "        n",
      "    } else {",
      "        digit_sum((n as f64/b as f64).floor() as i64, b) + (n % b)",
      "    }",
      "}"
    ]
  },
  "Binary Search": {
    "prefix": "bin",
    "body": [
      "pub trait BinarySearch<T> {",
      "    fn lower_bound(&self, x: &T) -> usize;",
      "    fn upper_bound(&self, x: &T) -> usize;",
      "}",
      "impl<T: Ord> BinarySearch<T> for [T] {",
      "    fn lower_bound(&self, x: &T) -> usize {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                Ordering::Less => {",
      "                    low = mid + 1;",
      "                }",
      "                Ordering::Equal | Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        low",
      "    }",
      "    fn upper_bound(&self, x: &T) -> usize {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                Ordering::Less | Ordering::Equal => {",
      "                    low = mid + 1;",
      "                }",
      "                Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        low",
      "    }",
      "}"
    ]
  },
  "Total Order": {
    "prefix": "total",
    "body": [
      "#[derive(PartialEq, PartialOrd, Clone, Debug)]",
      "pub struct Total<T>(pub T);",
      "impl<T: PartialEq> Eq for Total<T> {}",
      "impl<T: PartialOrd> Ord for Total<T> {",
      "    fn cmp(&self, other: &Total<T>) -> Ordering {",
      "        self.0.partial_cmp(&other.0).unwrap()",
      "    }",
      "}",
    ]
  },
  "Reverse": {
    "prefix": "reverse",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "pub struct Rev<T>(pub T);",
      "impl<T: PartialOrd> PartialOrd for Rev<T> {",
      "    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {",
      "        other.0.partial_cmp(&self.0)",
      "    }",
      "}",
      "impl<T: Ord> Ord for Rev<T> {",
      "    fn cmp(&self, other: &Rev<T>) -> Ordering {",
      "        other.0.cmp(&self.0)",
      "    }",
      "}",
    ]
  },
  "lexical permutation": {
    "prefix": "permu",
    "body": [
      "//thanks for https://github.com/bluss/permutohedron/blob/master/src/lexical.rs",
      "pub trait LexicalPermutation {",
      "    fn next_permutation(&mut self) -> bool;",
      "    fn prev_permutation(&mut self) -> bool;",
      "}",
      "impl<T> LexicalPermutation for [T] where T: Ord {",
      "    fn next_permutation(&mut self) -> bool {",
      "        if self.len() < 2 { return false; }",
      "        let mut i = self.len() - 1;",
      "        while i > 0 && self[i-1] >= self[i] {",
      "            i -= 1;",
      "        }",
      "        if i == 0 {",
      "            return false;",
      "        }",
      "        let mut j = self.len() - 1;",
      "        while j >= i && self[j] <= self[i-1]  {",
      "            j -= 1;",
      "        }",
      "        self.swap(j, i-1);",
      "        self[i..].reverse();",
      "        true",
      "    }",
      "    fn prev_permutation(&mut self) -> bool {",
      "        if self.len() < 2 { return false; }",
      "        let mut i = self.len() - 1;",
      "        while i > 0 && self[i-1] <= self[i] {",
      "            i -= 1;",
      "        }",
      "        if i == 0 {",
      "            return false;",
      "        }",
      "        self[i..].reverse();",
      "        let mut j = self.len() - 1;",
      "        while j >= i && self[j-1] < self[i-1]  {",
      "            j -= 1;",
      "        }",
      "        self.swap(i-1, j);",
      "        true",
      "    }",
      "}",
    ]
  },
  "read char": {
    "prefix": "readch",
    "body": [
      "use std::io::*;",
      "use std::str::FromStr;",
      "fn read<T: FromStr>() -> T {",
      "    let stdin = stdin();",
      "    let stdin = stdin.lock();",
      "    let token: String = stdin",
      "        .bytes()",
      "        .map(|c| c.expect(\"failed to read char\") as char) ",
      "        .skip_while(|c| c.is_whitespace())",
      "        .take_while(|c| !c.is_whitespace())",
      "        .collect();",
      "    token.parse().ok().expect(\"failed to parse token\")",
      "}",
      "fn read_char() -> char {",
      "    let s: String = read();",
      "    s.chars().collect::<Vec<char>>()[0]",
      "}",
    ]
  },
  "Warshall Floyd": {
    "prefix": "warshallfloyd",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct WarshallFloyd {",
      "    dist: Vec<Vec<isize>>,",
      "    next: Vec<Vec<usize>>,",
      "    n: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl WarshallFloyd {",
      "    fn new(n: usize, edges: &Vec<(usize, usize, isize)>) -> Self {",
      "        let inf: isize = 1000000007;",
      "        let mut dist: Vec<Vec<isize>> = vec![vec![inf as isize; n]; n];",
      "        let mut next: Vec<Vec<usize>> = vec![vec![0; n]; n];",
      "        for &(a, b, c) in edges.into_iter() {",
      "            dist[a][b] = c;",
      "        }",
      "        for i in 0..n {",
      "            dist[i][i] = 0;",
      "        }",
      "        for i in 0..n {",
      "            for j in 0..n {",
      "                next[i][j] = j;",
      "            }",
      "        }",
      "        for k in 0..n {",
      "            for i in 0..n {",
      "                for j in 0..n {",
      "                    if dist[i][j] > dist[i][k] + dist[k][j] {",
      "                        dist[i][j] = dist[i][k] + dist[k][j];",
      "                        next[i][j] = next[i][k];",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        WarshallFloyd {",
      "            dist: dist,",
      "            next: next,",
      "            n: n",
      "        }",
      "    }",
      "    fn get_path(&mut self, i: usize, j: usize) -> Vec<usize> {",
      "        let mut path = vec![];",
      "        let mut to = self.next[i][j];",
      "        path.push(i);",
      "        while to != j {",
      "            path.push(to);",
      "            to = self.next[to][j];",
      "        }",
      "        path.push(to);",
      "        path",
      "    }",
      "    fn has_negative_loop(&mut self) -> bool {",
      "        for i in 0..self.n {",
      "            if self.dist[i][i] < 0 {",
      "                return true",
      "            }",
      "        }",
      "        false",
      "    }",
      "}",
    ]
  },
  "Eratosthenes": {
    "prefix": "eratosthenes",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct Eratosthenes {",
      "    end: usize,",
      "    primes: Vec<usize>,",
      "    flags: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl Eratosthenes {",
      "    fn new(n: usize) -> Self {",
      "        let bits = 32;",
      "        let flags_num = n / bits + 1;",
      "        let defaults: Vec<usize> = vec![0x5D75D75D, 0xD75D75D7, 0x75D75D75];",
      "        let (mut i, mut f, mut j);",
      "        let max = ((n as f32).sqrt() as usize) + 1;",
      "        let mut flags: Vec<usize> = (0..flags_num).map(|i| defaults[i % 3]).collect();",
      "        flags[flags_num - 1] &= (1 << (n % bits + 1)) - 1 ;",
      "        i = 5;",
      "        f = 4;",
      "        while i <= max {",
      "            let t = (flags[i / bits] >> (i % bits)) & 1 == 1;",
      "            if !t {",
      "                j = i * (i | 1);",
      "                while j <= n {",
      "                    flags[j / bits] |= 1 << (j % bits);",
      "                    j += i * 2;",
      "                }",
      "            }",
      "            f = 6 - f;",
      "            i += f;",
      "        }",
      "        flags[0] &= !0b1100;",
      "        flags[0] |= 0b11;",
      "        let mut primes = vec![];",
      "        for p in 2..n+1 {",
      "            if (flags[p / bits] >> (p % bits)) & 1 == 0 {",
      "                primes.push(p);",
      "            }",
      "        }",
      "        Eratosthenes {",
      "            end: n,",
      "            primes: primes,",
      "            flags: flags,",
      "        }",
      "    }",
      "    fn is_prime(&self, m: usize) -> bool {",
      "        self.flags[m / 32] >> (m % 32) & 1 == 0",
      "    }",
      "    fn factorization(&self, n: usize) -> HashMap<usize, usize> {",
      "        let mut n = n;",
      "        let mut factors: HashMap<usize, usize> = HashMap::new();",
      "        for &p in &self.primes {",
      "            while n % p == 0 {",
      "                n /= p;",
      "                *factors.entry(p).or_insert(0) += 1;",
      "            }",
      "            if p > n {",
      "                break;",
      "            }",
      "        }",
      "        factors",
      "    }",
      "}",
    ]
  },
  "Dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct Dijkstra {",
      "    dist: Vec<isize>,",
      "    neighbors: Vec<Vec<(usize, isize)>>,",
      "    n: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl Dijkstra {",
      "    fn new(n: usize, edges: &Vec<(usize, usize, isize)>, s: usize) -> Self {",
      "        let inf: isize = 1000000007;",
      "        let mut dist: Vec<isize> = vec![inf; n];",
      "        let mut neighbors: Vec<Vec<(usize, isize)>> = vec![vec![]; n];",
      "        let mut heap: BinaryHeap<Rev<(usize, isize)>> = BinaryHeap::new();",
      "        for &(a, b, c) in edges.into_iter() {",
      "            neighbors[a].push((b, c));",
      "        }",
      "        dist[s] = 0;",
      "        heap.push(Rev((s, 0)));",
      "        while !heap.is_empty() {",
      "            let Rev((v, d)) = heap.pop().unwrap();",
      "            if dist[v] < d {",
      "                continue;",
      "            }",
      "            for &(u, cost) in &neighbors[v] {",
      "                if dist[u] > dist[v] + cost {",
      "                    dist[u] = dist[v] + cost;",
      "                    heap.push(Rev((u, cost)));",
      "                }",
      "            }",
      "        }",
      "        Dijkstra {",
      "            dist: dist,",
      "            neighbors: neighbors,",
      "            n: n,",
      "        }",
      "    }",
      "}",
    ]
  },
  "programmingContenst": {
    "prefix": "pro",
    "body": [
      "#![allow(non_snake_case)]",
      "#[allow(unused_imports)]",
      "use std::io::{self, Write};",
      "#[allow(unused_imports)]",
      "use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};",
      "#[allow(unused_imports)]",
      "use std::cmp::{max, min, Ordering};",
      "macro_rules! input {",
      "    (source = \\$s:expr, \\$(\\$r:tt)*) => {",
      "        let mut iter = \\$s.split_whitespace();",
      "        let mut next = || { iter.next().unwrap() };",
      "        input_inner!{next, \\$(\\$r)*}",
      "    };",
      "    (\\$(\\$r:tt)*) => {",
      "        let stdin = std::io::stdin();",
      "        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));",
      "        let mut next = move || -> String{",
      "            bytes",
      "                .by_ref()",
      "                .map(|r|r.unwrap() as char)",
      "                .skip_while(|c|c.is_whitespace())",
      "                .take_while(|c|!c.is_whitespace())",
      "                .collect()",
      "        };",
      "        input_inner!{next, \\$(\\$r)*}",
      "    };",
      "}",
      "macro_rules! input_inner {",
      "    (\\$next:expr) => {};",
      "    (\\$next:expr, ) => {};",
      "    (\\$next:expr, \\$var:ident : \\$t:tt \\$(\\$r:tt)*) => {",
      "        let \\$var = read_value!(\\$next, \\$t);",
      "        input_inner!{\\$next \\$(\\$r)*}",
      "    };",
      "}",
      "macro_rules! read_value {",
      "    (\\$next:expr, ( \\$(\\$t:tt),* )) => {",
      "        ( \\$(read_value!(\\$next, \\$t)),* )",
      "    };",
      "    (\\$next:expr, [ \\$t:tt ; \\$len:expr ]) => {",
      "        (0..\\$len).map(|_| read_value!(\\$next, \\$t)).collect::<Vec<_>>()",
      "    };",
      "    (\\$next:expr, chars) => {",
      "        read_value!(\\$next, String).chars().collect::<Vec<char>>()",
      "    };",
      "    (\\$next:expr, char) => {",
      "        read_value!(\\$next, String).chars().collect::<Vec<char>>()[0]",
      "     };",
      "    (\\$next:expr, usize1) => {",
      "        read_value!(\\$next, usize) - 1",
      "     };",
      "    (\\$next:expr, isize1) => {",
      "        read_value!(\\$next, isize) - 1",
      "    };",
      "     (\\$next:expr, \\$t:ty) => {",
      "         \\$next().parse::<\\$t>().expect(\"Parse error\")",
      "    };",
      "}",
      "macro_rules! debug {",
      "    (\\$(\\$a:expr),*) => {",
      "        println!(concat!(\\$(stringify!(\\$a), \" = {:?}, \"),*), \\$(\\$a),*);",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "const MOD: usize = 1000000007;",
      "#[allow(dead_code)]",
      "fn to_num(c: char) -> i64 {",
      "    c as i64 - 48",
      "}",
      "\n",
      "fn main() {",
      "    input!{",
      "        $N",
      "    }",
      "}"
    ],
  }
}